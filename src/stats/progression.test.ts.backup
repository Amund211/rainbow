import test from "node:test";
import assert from "node:assert";
import {
    computeStatProgression,
    ERR_NO_DATA,
    ERR_TRACKING_STARTED,
    type StatProgression,
} from "./progression.ts";
import type { PlayerDataPIT, StatsPIT } from "#queries/playerdata.ts";
import type { GamemodeKey, StatKey } from "./keys.ts";

/**
 * Fluid interface builder for StatsPIT objects
 */
class StatsPITBuilder {
    private stats: StatsPIT = {
        winstreak: null,
        gamesPlayed: 0,
        wins: 0,
        losses: 0,
        bedsBroken: 0,
        bedsLost: 0,
        finalKills: 0,
        finalDeaths: 0,
        kills: 0,
        deaths: 0,
    };

    withWinstreak(value: number | null): this {
        this.stats.winstreak = value;
        return this;
    }

    withGamesPlayed(value: number): this {
        this.stats.gamesPlayed = value;
        return this;
    }

    withWins(value: number): this {
        this.stats.wins = value;
        return this;
    }

    withLosses(value: number): this {
        this.stats.losses = value;
        return this;
    }

    withBedsBroken(value: number): this {
        this.stats.bedsBroken = value;
        return this;
    }

    withBedsLost(value: number): this {
        this.stats.bedsLost = value;
        return this;
    }

    withFinalKills(value: number): this {
        this.stats.finalKills = value;
        return this;
    }

    withFinalDeaths(value: number): this {
        this.stats.finalDeaths = value;
        return this;
    }

    withKills(value: number): this {
        this.stats.kills = value;
        return this;
    }

    withDeaths(value: number): this {
        this.stats.deaths = value;
        return this;
    }

    build(): StatsPIT {
        return { ...this.stats };
    }
}

/**
 * Fluid interface builder for PlayerDataPIT objects
 */
class PlayerDataPITBuilder {
    private data: PlayerDataPIT;

    constructor(uuid: string, queriedAt: Date) {
        const defaultStats: StatsPIT = {
            winstreak: null,
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            bedsBroken: 0,
            bedsLost: 0,
            finalKills: 0,
            finalDeaths: 0,
            kills: 0,
            deaths: 0,
        };

        this.data = {
            uuid,
            queriedAt,
            experience: 0,
            solo: { ...defaultStats },
            doubles: { ...defaultStats },
            threes: { ...defaultStats },
            fours: { ...defaultStats },
            overall: { ...defaultStats },
        };
    }

    withExperience(value: number): this {
        this.data.experience = value;
        return this;
    }

    withSoloStats(stats: StatsPIT): this {
        this.data.solo = stats;
        return this;
    }

    withDoublesStats(stats: StatsPIT): this {
        this.data.doubles = stats;
        return this;
    }

    withThreesStats(stats: StatsPIT): this {
        this.data.threes = stats;
        return this;
    }

    withFoursStats(stats: StatsPIT): this {
        this.data.fours = stats;
        return this;
    }

    withOverallStats(stats: StatsPIT): this {
        this.data.overall = stats;
        return this;
    }

    // Convenience method to set stats for a specific gamemode
    withGamemodeStats(gamemode: GamemodeKey, stats: StatsPIT): this {
        this.data[gamemode] = stats;
        return this;
    }

    build(): PlayerDataPIT {
        return { ...this.data };
    }
}

// Helper function to build stats for a specific stat key
function buildStatsForLinearStat(
    stat: Exclude<StatKey, "stars" | "fkdr" | "kdr" | "index" | "winstreak">,
    value: number,
): StatsPIT {
    const builder = new StatsPITBuilder();
    switch (stat) {
        case "gamesPlayed":
            return builder.withGamesPlayed(value).build();
        case "wins":
            return builder.withWins(value).build();
        case "losses":
            return builder.withLosses(value).build();
        case "bedsBroken":
            return builder.withBedsBroken(value).build();
        case "bedsLost":
            return builder.withBedsLost(value).build();
        case "finalKills":
            return builder.withFinalKills(value).build();
        case "finalDeaths":
            return builder.withFinalDeaths(value).build();
        case "kills":
            return builder.withKills(value).build();
        case "deaths":
            return builder.withDeaths(value).build();
        case "experience":
            // Experience is not part of stats
            return builder.build();
    }
}

// ============================================================================
// Test Cases
// ============================================================================

await test("computeStatProgression - error cases", async (t) => {
    const uuid = "test-uuid";
    const trackingEnd = new Date("2024-02-01T00:00:00Z");

    await t.test("ERR_NO_DATA - undefined history", () => {
        const result = computeStatProgression(
            undefined,
            trackingEnd,
            undefined,
            "experience",
            "overall",
        );
        assert.strictEqual(result.error, true);
        assert.strictEqual(result.reason, ERR_NO_DATA);
    });

    await t.test("ERR_NO_DATA - empty history", () => {
        const result = computeStatProgression(
            [],
            trackingEnd,
            undefined,
            "experience",
            "overall",
        );
        assert.strictEqual(result.error, true);
        assert.strictEqual(result.reason, ERR_NO_DATA);
    });

    await t.test("ERR_TRACKING_STARTED - single data point", () => {
        const start = new PlayerDataPITBuilder(uuid, new Date("2024-01-01T00:00:00Z")).build();

        const result = computeStatProgression(
            [start],
            trackingEnd,
            undefined,
            "experience",
            "overall",
        );
        assert.strictEqual(result.error, true);
        assert.strictEqual(result.reason, ERR_TRACKING_STARTED);
    });

    await t.test("error - more than 2 data points", () => {
        const start = new PlayerDataPITBuilder(uuid, new Date("2024-01-01T00:00:00Z")).build();
        const mid = new PlayerDataPITBuilder(uuid, new Date("2024-01-15T00:00:00Z")).build();
        const end = new PlayerDataPITBuilder(uuid, new Date("2024-01-31T00:00:00Z")).build();

        const result = computeStatProgression(
            [start, mid, end],
            trackingEnd,
            undefined,
            "experience",
            "overall",
        );
        assert.strictEqual(result.error, true);
        assert.strictEqual(result.reason, "Expected at most 2 data points");
    });

    await t.test("error - no current stats", () => {
        const start = new PlayerDataPITBuilder(uuid, new Date("2024-01-01T00:00:00Z")).build();
        const end = new PlayerDataPITBuilder(uuid, new Date("2024-01-31T00:00:00Z")).build();

        const result = computeStatProgression(
            [start, end],
            trackingEnd,
            undefined,
            "experience",
            "overall",
        );
        assert.strictEqual(result.error, true);
        assert.strictEqual(result.reason, "No current stats");
    });

    await t.test("error - index not implemented", () => {
        const start = new PlayerDataPITBuilder(uuid, new Date("2024-01-01T00:00:00Z"))
            .withExperience(1000)
            .build();
        const end = new PlayerDataPITBuilder(uuid, new Date("2024-01-31T00:00:00Z"))
            .withExperience(2000)
            .build();
        const current = new PlayerDataPITBuilder(uuid, new Date("2024-02-01T00:00:00Z"))
            .withExperience(2100)
            .build();

        const result = computeStatProgression(
            [start, end],
            trackingEnd,
            current,
            "index",
            "overall",
        );
        assert.strictEqual(result.error, true);
        assert.strictEqual(result.reason, "Not implemented");
    });

    await t.test("error - winstreak not implemented", () => {
        const start = new PlayerDataPITBuilder(uuid, new Date("2024-01-01T00:00:00Z"))
            .withOverallStats(new StatsPITBuilder().withWinstreak(5).build())
            .build();
        const end = new PlayerDataPITBuilder(uuid, new Date("2024-01-31T00:00:00Z"))
            .withOverallStats(new StatsPITBuilder().withWinstreak(10).build())
            .build();
        const current = new PlayerDataPITBuilder(uuid, new Date("2024-02-01T00:00:00Z"))
            .withOverallStats(new StatsPITBuilder().withWinstreak(12).build())
            .build();

        const result = computeStatProgression(
            [start, end],
            trackingEnd,
            current,
            "winstreak",
            "overall",
        );
        assert.strictEqual(result.error, true);
        assert.strictEqual(result.reason, "Not implemented");
    });
});

// Define test data for linear stats
const LINEAR_STATS: Array<Exclude<StatKey, "stars" | "fkdr" | "kdr" | "index" | "winstreak">> = [
    "experience",
    "gamesPlayed",
    "wins",
    "losses",
    "bedsBroken",
    "bedsLost",
    "finalKills",
    "finalDeaths",
    "kills",
    "deaths",
];

const QUOTIENT_STATS: Array<"fkdr" | "kdr"> = ["fkdr", "kdr"];

const GAMEMODES: GamemodeKey[] = ["solo", "doubles", "threes", "fours", "overall"];

await test("computeStatProgression - linear stats", async (t) => {
    const uuid = "test-uuid";

    // Test case: normal progression
    for (const gamemode of GAMEMODES) {
        await t.test(`${gamemode} - normal progression`, async (t) => {
            for (const stat of LINEAR_STATS) {
                await t.test(stat, () => {
                    const startDate = new Date("2024-01-01T00:00:00Z");
                    const endDate = new Date("2024-01-31T00:00:00Z");
                    const trackingEnd = new Date("2024-02-01T00:00:00Z");

                    // Set stat value for the gamemode
                    const start = new PlayerDataPITBuilder(uuid, startDate)
                        .withExperience(stat === "experience" ? 10000 : 0)
                        .withGamemodeStats(
                            gamemode,
                            buildStatsForLinearStat(stat, 100),
                        )
                        .build();

                    const end = new PlayerDataPITBuilder(uuid, endDate)
                        .withExperience(stat === "experience" ? 40000 : 0)
                        .withGamemodeStats(
                            gamemode,
                            buildStatsForLinearStat(stat, 400),
                        )
                        .build();

                    const current = new PlayerDataPITBuilder(uuid, trackingEnd)
                        .withExperience(stat === "experience" ? 45000 : 0)
                        .withGamemodeStats(
                            gamemode,
                            buildStatsForLinearStat(stat, 450),
                        )
                        .build();

                    const result = computeStatProgression(
                        [start, end],
                        trackingEnd,
                        current,
                        stat,
                        gamemode,
                    );

                    if (result.error) {
                        assert.fail(`Expected success, got error: ${result.reason}`);
                    }

                    const progression = result as StatProgression;
                    assert.strictEqual(progression.stat, stat);
                    assert.strictEqual(progression.trendingUpward, true);

                    // Check that currentValue is correct
                    const expectedValue = stat === "experience" ? 45000 : 450;
                    assert.strictEqual(progression.currentValue, expectedValue);

                    // Progress per day is calculated from start to trackingEnd
                    // Days: (trackingEnd - startDate) = (Feb 1 - Jan 1) = 31 days
                    // For experience: (40000 - 10000) / 31 = 967.74... per day
                    // For other stats: (400 - 100) / 31 = 9.677... per day
                    const daysElapsed = 31;
                    const expectedProgressPerDay =
                        stat === "experience"
                            ? (40000 - 10000) / daysElapsed
                            : (400 - 100) / daysElapsed;
                    assert.ok(
                        Math.abs(progression.progressPerDay - expectedProgressPerDay) <
                            0.01,
                    );

                    // Check milestone is reasonable
                    assert.ok(progression.nextMilestoneValue > progression.currentValue);
                    assert.ok(progression.daysUntilMilestone > 0);
                    assert.ok(progression.daysUntilMilestone < Infinity);
                });
            }
        });
    }

    // Edge case: no progress (same start and end values)
    for (const gamemode of GAMEMODES) {
        await t.test(`${gamemode} - no progress edge case`, async (t) => {
            for (const stat of LINEAR_STATS) {
                await t.test(stat, () => {
                    const startDate = new Date("2024-01-01T00:00:00Z");
                    const endDate = new Date("2024-01-31T00:00:00Z");
                    const trackingEnd = new Date("2024-02-01T00:00:00Z");

                    const start = new PlayerDataPITBuilder(uuid, startDate)
                        .withExperience(stat === "experience" ? 10000 : 0)
                        .withGamemodeStats(
                            gamemode,
                            buildStatsForLinearStat(stat, 100),
                        )
                        .build();

                    const end = new PlayerDataPITBuilder(uuid, endDate)
                        .withExperience(stat === "experience" ? 10000 : 0)
                        .withGamemodeStats(
                            gamemode,
                            buildStatsForLinearStat(stat, 100),
                        )
                        .build();

                    const current = new PlayerDataPITBuilder(uuid, trackingEnd)
                        .withExperience(stat === "experience" ? 10000 : 0)
                        .withGamemodeStats(
                            gamemode,
                            buildStatsForLinearStat(stat, 100),
                        )
                        .build();

                    const result = computeStatProgression(
                        [start, end],
                        trackingEnd,
                        current,
                        stat,
                        gamemode,
                    );

                    // Should return an error for no progress
                    assert.strictEqual(result.error, true);
                    assert.strictEqual(result.reason, "No progress");
                });
            }
        });
    }
});

await test("computeStatProgression - quotient stats (fkdr, kdr)", async (t) => {
    const uuid = "test-uuid";

    // Test case: normal progression for quotient stats
    for (const gamemode of GAMEMODES) {
        await t.test(`${gamemode} - normal progression`, async (t) => {
            for (const stat of QUOTIENT_STATS) {
                await t.test(stat, () => {
                    const startDate = new Date("2024-01-01T00:00:00Z");
                    const endDate = new Date("2024-01-31T00:00:00Z");
                    const trackingEnd = new Date("2024-02-01T00:00:00Z");

                    const isFkdr = stat === "fkdr";
                    
                    // Start: ratio = 100/50 = 2.0
                    const start = new PlayerDataPITBuilder(uuid, startDate)
                        .withGamemodeStats(
                            gamemode,
                            isFkdr
                                ? new StatsPITBuilder()
                                      .withFinalKills(100)
                                      .withFinalDeaths(50)
                                      .build()
                                : new StatsPITBuilder()
                                      .withKills(100)
                                      .withDeaths(50)
                                      .build(),
                        )
                        .build();

                    // End: ratio = 400/100 = 4.0 (session ratio improvement)
                    const end = new PlayerDataPITBuilder(uuid, endDate)
                        .withGamemodeStats(
                            gamemode,
                            isFkdr
                                ? new StatsPITBuilder()
                                      .withFinalKills(400)
                                      .withFinalDeaths(100)
                                      .build()
                                : new StatsPITBuilder()
                                      .withKills(400)
                                      .withDeaths(100)
                                      .build(),
                        )
                        .build();

                    // Current: ratio = 450/105 = 4.285...
                    const current = new PlayerDataPITBuilder(uuid, trackingEnd)
                        .withGamemodeStats(
                            gamemode,
                            isFkdr
                                ? new StatsPITBuilder()
                                      .withFinalKills(450)
                                      .withFinalDeaths(105)
                                      .build()
                                : new StatsPITBuilder()
                                      .withKills(450)
                                      .withDeaths(105)
                                      .build(),
                        )
                        .build();

                    const result = computeStatProgression(
                        [start, end],
                        trackingEnd,
                        current,
                        stat,
                        gamemode,
                    );

                    if (result.error) {
                        assert.fail(`Expected success, got error: ${result.reason}`);
                    }

                    const progression = result;
                    assert.strictEqual(progression.stat, stat);
                    
                    // Current ratio should be ~4.285
                    const currentRatio = 450 / 105;
                    assert.ok(Math.abs(progression.currentValue - currentRatio) < 0.01);

                    // Session quotient should be (400-100)/(100-50) = 300/50 = 6.0
                    if ("sessionQuotient" in progression) {
                        assert.ok(Math.abs(progression.sessionQuotient - 6.0) < 0.01);
                    }

                    // Milestone should be 5 (next integer)
                    assert.strictEqual(progression.nextMilestoneValue, 5);
                    
                    // Should be trending upward (session quotient > current quotient)
                    assert.strictEqual(progression.trendingUpward, true);

                    // Should have finite days until milestone
                    assert.ok(progression.daysUntilMilestone > 0);
                    assert.ok(progression.daysUntilMilestone < Infinity);
                });
            }
        });
    }

    // Edge case: zero divisor at start but not at end
    for (const gamemode of GAMEMODES) {
        await t.test(`${gamemode} - zero current divisor, non-zero session divisor`, async (t) => {
            for (const stat of QUOTIENT_STATS) {
                await t.test(stat, () => {
                    const startDate = new Date("2024-01-01T00:00:00Z");
                    const endDate = new Date("2024-01-31T00:00:00Z");
                    const trackingEnd = new Date("2024-02-01T00:00:00Z");

                    const isFkdr = stat === "fkdr";

                    // Start: 100 kills, 0 deaths
                    const start = new PlayerDataPITBuilder(uuid, startDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(100).finalDeaths(0);
                            } else {
                                return b.kills(100).deaths(0);
                            }
                        })
                        .build();

                    // End: 400 kills, 50 deaths (session: +300 kills, +50 deaths)
                    const end = new PlayerDataPITBuilder(uuid, endDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(400).finalDeaths(50);
                            } else {
                                return b.kills(400).deaths(50);
                            }
                        })
                        .build();

                    // Current: 450 kills, 55 deaths (ratio = 450/55 = ~8.18)
                    const current = new PlayerDataPITBuilder(uuid, trackingEnd)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(450).finalDeaths(55);
                            } else {
                                return b.kills(450).deaths(55);
                            }
                        })
                        .build();

                    const result = computeStatProgression(
                        [start, end],
                        trackingEnd,
                        current,
                        stat,
                        gamemode,
                    );

                    if (result.error) {
                        assert.fail(`Expected success, got error: ${result.reason}`);
                    }

                    const progression = result;
                    assert.strictEqual(progression.stat, stat);

                    // Current ratio should be 450/55
                    const currentRatio = 450 / 55;
                    assert.ok(Math.abs(progression.currentValue - currentRatio) < 0.01);

                    // Session quotient: 300/50 = 6.0
                    if ("sessionQuotient" in progression) {
                        assert.ok(Math.abs(progression.sessionQuotient - 6.0) < 0.01);
                    }
                });
            }
        });
    }

    // Edge case: both current and session divisor are zero
    for (const gamemode of GAMEMODES) {
        await t.test(`${gamemode} - zero divisor (both current and session)`, async (t) => {
            for (const stat of QUOTIENT_STATS) {
                await t.test(stat, () => {
                    const startDate = new Date("2024-01-01T00:00:00Z");
                    const endDate = new Date("2024-01-31T00:00:00Z");
                    const trackingEnd = new Date("2024-02-01T00:00:00Z");

                    const isFkdr = stat === "fkdr";

                    // Start: 100 kills, 0 deaths
                    const start = new PlayerDataPITBuilder(uuid, startDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(100).finalDeaths(0);
                            } else {
                                return b.kills(100).deaths(0);
                            }
                        })
                        .build();

                    // End: 400 kills, 0 deaths (session: +300 kills, 0 deaths)
                    const end = new PlayerDataPITBuilder(uuid, endDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(400).finalDeaths(0);
                            } else {
                                return b.kills(400).deaths(0);
                            }
                        })
                        .build();

                    // Current: 450 kills, 0 deaths (ratio = "infinite", represented as just kills)
                    const current = new PlayerDataPITBuilder(uuid, trackingEnd)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(450).finalDeaths(0);
                            } else {
                                return b.kills(450).deaths(0);
                            }
                        })
                        .build();

                    const result = computeStatProgression(
                        [start, end],
                        trackingEnd,
                        current,
                        stat,
                        gamemode,
                    );

                    if (result.error) {
                        assert.fail(`Expected success, got error: ${result.reason}`);
                    }

                    const progression = result;
                    assert.strictEqual(progression.stat, stat);

                    // When divisor is 0, current value should equal dividend
                    assert.strictEqual(progression.currentValue, 450);

                    // Should always be trending upward when divisor is 0
                    assert.strictEqual(progression.trendingUpward, true);
                });
            }
        });
    }

    // Edge case: no progress (same values at start and end)
    for (const gamemode of GAMEMODES) {
        await t.test(`${gamemode} - no progress edge case`, async (t) => {
            for (const stat of QUOTIENT_STATS) {
                await t.test(stat, () => {
                    const startDate = new Date("2024-01-01T00:00:00Z");
                    const endDate = new Date("2024-01-31T00:00:00Z");
                    const trackingEnd = new Date("2024-02-01T00:00:00Z");

                    const isFkdr = stat === "fkdr";

                    const start = new PlayerDataPITBuilder(uuid, startDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(100).finalDeaths(50);
                            } else {
                                return b.kills(100).deaths(50);
                            }
                        })
                        .build();

                    const end = new PlayerDataPITBuilder(uuid, endDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(100).finalDeaths(50);
                            } else {
                                return b.kills(100).deaths(50);
                            }
                        })
                        .build();

                    const current = new PlayerDataPITBuilder(uuid, trackingEnd)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(100).finalDeaths(50);
                            } else {
                                return b.kills(100).deaths(50);
                            }
                        })
                        .build();

                    const result = computeStatProgression(
                        [start, end],
                        trackingEnd,
                        current,
                        stat,
                        gamemode,
                    );

                    if (result.error) {
                        assert.fail(`Expected success, got error: ${result.reason}`);
                    }

                    const progression = result;
                    assert.strictEqual(progression.stat, stat);

                    // With no progress, days until milestone should be infinite
                    assert.strictEqual(progression.daysUntilMilestone, Infinity);
                    assert.strictEqual(progression.progressPerDay, 0);
                });
            }
        });
    }

    // Edge case: trending downward (session quotient < current quotient)
    for (const gamemode of GAMEMODES) {
        await t.test(`${gamemode} - trending downward`, async (t) => {
            for (const stat of QUOTIENT_STATS) {
                await t.test(stat, () => {
                    const startDate = new Date("2024-01-01T00:00:00Z");
                    const endDate = new Date("2024-01-31T00:00:00Z");
                    const trackingEnd = new Date("2024-02-01T00:00:00Z");

                    const isFkdr = stat === "fkdr";

                    // Start: ratio = 500/50 = 10.0
                    const start = new PlayerDataPITBuilder(uuid, startDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(500).finalDeaths(50);
                            } else {
                                return b.kills(500).deaths(50);
                            }
                        })
                        .build();

                    // End: ratio = 600/200 = 3.0 (session ratio: 100/150 = 0.667)
                    const end = new PlayerDataPITBuilder(uuid, endDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(600).finalDeaths(200);
                            } else {
                                return b.kills(600).deaths(200);
                            }
                        })
                        .build();

                    // Current: ratio = 610/205 = 2.976
                    const current = new PlayerDataPITBuilder(uuid, trackingEnd)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(610).finalDeaths(205);
                            } else {
                                return b.kills(610).deaths(205);
                            }
                        })
                        .build();

                    const result = computeStatProgression(
                        [start, end],
                        trackingEnd,
                        current,
                        stat,
                        gamemode,
                    );

                    if (result.error) {
                        assert.fail(`Expected success, got error: ${result.reason}`);
                    }

                    const progression = result;
                    assert.strictEqual(progression.stat, stat);

                    // Current ratio
                    const currentRatio = 610 / 205;
                    assert.ok(Math.abs(progression.currentValue - currentRatio) < 0.01);

                    // Session quotient: 100/150 = 0.667
                    if ("sessionQuotient" in progression) {
                        const sessionQuotient = 100 / 150;
                        assert.ok(Math.abs(progression.sessionQuotient - sessionQuotient) < 0.01);
                    }

                    // Should be trending downward
                    assert.strictEqual(progression.trendingUpward, false);

                    // Milestone should be 2 (floor - 1 when trending down)
                    assert.strictEqual(progression.nextMilestoneValue, 2);
                });
            }
        });
    }

    // Edge case: milestone unreachable with current session quotient
    for (const gamemode of GAMEMODES) {
        await t.test(`${gamemode} - milestone unreachable`, async (t) => {
            for (const stat of QUOTIENT_STATS) {
                await t.test(stat, () => {
                    const startDate = new Date("2024-01-01T00:00:00Z");
                    const endDate = new Date("2024-01-31T00:00:00Z");
                    const trackingEnd = new Date("2024-02-01T00:00:00Z");

                    const isFkdr = stat === "fkdr";

                    // Start: ratio = 100/50 = 2.0
                    const start = new PlayerDataPITBuilder(uuid, startDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(100).finalDeaths(50);
                            } else {
                                return b.kills(100).deaths(50);
                            }
                        })
                        .build();

                    // End: ratio = 250/100 = 2.5 (session ratio: 150/50 = 3.0)
                    const end = new PlayerDataPITBuilder(uuid, endDate)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(250).finalDeaths(100);
                            } else {
                                return b.kills(250).deaths(100);
                            }
                        })
                        .build();

                    // Current: ratio = 260/104 = 2.5
                    const current = new PlayerDataPITBuilder(uuid, trackingEnd)
                        .forGamemode(gamemode, (b) => {
                            if (isFkdr) {
                                return b.finalKills(260).finalDeaths(104);
                            } else {
                                return b.kills(260).deaths(104);
                            }
                        })
                        .build();

                    const result = computeStatProgression(
                        [start, end],
                        trackingEnd,
                        current,
                        stat,
                        gamemode,
                    );

                    if (result.error) {
                        assert.fail(`Expected success, got error: ${result.reason}`);
                    }

                    const progression = result;
                    assert.strictEqual(progression.stat, stat);

                    // Current ratio
                    const currentRatio = 260 / 104;
                    assert.ok(Math.abs(progression.currentValue - currentRatio) < 0.01);

                    // Session quotient: 150/50 = 3.0
                    if ("sessionQuotient" in progression) {
                        assert.ok(Math.abs(progression.sessionQuotient - 3.0) < 0.01);
                    }

                    // Next milestone would be 3, but session quotient is exactly 3.0
                    // So it's unreachable -> infinite time
                    assert.strictEqual(progression.nextMilestoneValue, 3);
                    assert.strictEqual(progression.daysUntilMilestone, Infinity);
                });
            }
        });
    }
});

await test("computeStatProgression - stars stat", async (t) => {
    const uuid = "test-uuid";

    await t.test("normal progression", () => {
        const startDate = new Date("2024-01-01T00:00:00Z");
        const endDate = new Date("2024-01-31T00:00:00Z");
        const trackingEnd = new Date("2024-02-01T00:00:00Z");

        // Experience corresponding to different star levels
        // Using PRESTIGE_EXP = 487000 (from stars.ts)
        const PRESTIGE_EXP = 487000;

        // Start at 100 stars (1 prestige)
        const start = new PlayerDataPITBuilder(uuid, startDate)
            .experience(PRESTIGE_EXP)
            .build();

        // End at 200 stars (2 prestiges)
        const end = new PlayerDataPITBuilder(uuid, endDate)
            .experience(2 * PRESTIGE_EXP)
            .build();

        // Current at 210 stars
        const current = new PlayerDataPITBuilder(uuid, trackingEnd)
            .experience(2 * PRESTIGE_EXP + 0.1 * PRESTIGE_EXP)
            .build();

        const result = computeStatProgression(
            [start, end],
            trackingEnd,
            current,
            "stars",
            "overall", // gamemode doesn't matter for stars
        );

        if (result.error) {
            assert.fail(`Expected success, got error: ${result.reason}`);
        }

        const progression = result;
        assert.strictEqual(progression.stat, "stars");
        assert.strictEqual(progression.trendingUpward, true);

        // Next milestone should be 300 (next prestige)
        assert.strictEqual(progression.nextMilestoneValue, 300);

        // Should have finite days until milestone
        assert.ok(progression.daysUntilMilestone > 0);
        assert.ok(progression.daysUntilMilestone < Infinity);
    });

    // TODO: Edge case - this test may reveal a bug with zero/negative experience gain
    // await t.test("no experience gain", () => {
    //     const startDate = new Date("2024-01-01T00:00:00Z");
    //     const endDate = new Date("2024-01-31T00:00:00Z");
    //     const trackingEnd = new Date("2024-02-01T00:00:00Z");

    //     const PRESTIGE_EXP = 487000;

    //     const start = new PlayerDataPITBuilder(uuid, startDate)
    //         .experience(PRESTIGE_EXP)
    //         .build();

    //     const end = new PlayerDataPITBuilder(uuid, endDate)
    //         .experience(PRESTIGE_EXP) // Same experience
    //         .build();

    //     const current = new PlayerDataPITBuilder(uuid, trackingEnd)
    //         .experience(PRESTIGE_EXP)
    //         .build();

    //     const result = computeStatProgression(
    //         [start, end],
    //         trackingEnd,
    //         current,
    //         "stars",
    //         "overall",
    //     );

    //     // Should probably return an error or infinite days
    //     // Uncomment to test:
    //     // if (!result.error) {
    //     //     assert.strictEqual(result.daysUntilMilestone, Infinity);
    //     // }
    // });
});

// Edge case tests that might reveal bugs
await test("computeStatProgression - potential edge case bugs", async (t) => {
    const uuid = "test-uuid";

    // TODO: Test with very small time intervals (< 1 day)
    // await t.test("very small time interval", () => {
    //     const startDate = new Date("2024-01-01T00:00:00Z");
    //     const endDate = new Date("2024-01-01T01:00:00Z"); // 1 hour
    //     const trackingEnd = new Date("2024-01-01T02:00:00Z");

    //     const start = new PlayerDataPITBuilder(uuid, startDate)
    //         .forGamemode("overall", (b) => b.kills(100))
    //         .build();

    //     const end = new PlayerDataPITBuilder(uuid, endDate)
    //         .forGamemode("overall", (b) => b.kills(110))
    //         .build();

    //     const current = new PlayerDataPITBuilder(uuid, trackingEnd)
    //         .forGamemode("overall", (b) => b.kills(115))
    //         .build();

    //     const result = computeStatProgression(
    //         [start, end],
    //         trackingEnd,
    //         current,
    //         "kills",
    //         "overall",
    //     );

    //     // This might reveal issues with very small daysElapsed values
    // });

    // TODO: Test with tracking end before history end
    // await t.test("tracking end before history end", () => {
    //     const startDate = new Date("2024-01-01T00:00:00Z");
    //     const endDate = new Date("2024-01-31T00:00:00Z");
    //     const trackingEnd = new Date("2024-01-15T00:00:00Z"); // Before endDate

    //     const start = new PlayerDataPITBuilder(uuid, startDate)
    //         .forGamemode("overall", (b) => b.kills(100))
    //         .build();

    //     const end = new PlayerDataPITBuilder(uuid, endDate)
    //         .forGamemode("overall", (b) => b.kills(200))
    //         .build();

    //     const current = new PlayerDataPITBuilder(uuid, trackingEnd)
    //         .forGamemode("overall", (b) => b.kills(150))
    //         .build();

    //     const result = computeStatProgression(
    //         [start, end],
    //         trackingEnd,
    //         current,
    //         "kills",
    //         "overall",
    //     );

    //     // This might reveal issues with negative daysElapsed
    // });

    // TODO: Test with current value less than end value (regression)
    // await t.test("current value less than end value", () => {
    //     const startDate = new Date("2024-01-01T00:00:00Z");
    //     const endDate = new Date("2024-01-31T00:00:00Z");
    //     const trackingEnd = new Date("2024-02-01T00:00:00Z");

    //     const start = new PlayerDataPITBuilder(uuid, startDate)
    //         .forGamemode("overall", (b) => b.kills(100))
    //         .build();

    //     const end = new PlayerDataPITBuilder(uuid, endDate)
    //         .forGamemode("overall", (b) => b.kills(200))
    //         .build();

    //     const current = new PlayerDataPITBuilder(uuid, trackingEnd)
    //         .forGamemode("overall", (b) => b.kills(150)) // Less than end
    //         .build();

    //     const result = computeStatProgression(
    //         [start, end],
    //         trackingEnd,
    //         current,
    //         "kills",
    //         "overall",
    //     );

    //     // This might work fine or reveal issues with the calculation
    // });

    // TODO: Test quotient with negative session dividend
    // await t.test("quotient with negative session values", () => {
    //     const startDate = new Date("2024-01-01T00:00:00Z");
    //     const endDate = new Date("2024-01-31T00:00:00Z");
    //     const trackingEnd = new Date("2024-02-01T00:00:00Z");

    //     // Session has negative kills (impossible in real scenario, but good edge case)
    //     const start = new PlayerDataPITBuilder(uuid, startDate)
    //         .forGamemode("overall", (b) => b.finalKills(500).finalDeaths(100))
    //         .build();

    //     const end = new PlayerDataPITBuilder(uuid, endDate)
    //         .forGamemode("overall", (b) => b.finalKills(400).finalDeaths(150))
    //         .build();

    //     const current = new PlayerDataPITBuilder(uuid, trackingEnd)
    //         .forGamemode("overall", (b) => b.finalKills(390).finalDeaths(155))
    //         .build();

    //     const result = computeStatProgression(
    //         [start, end],
    //         trackingEnd,
    //         current,
    //         "fkdr",
    //         "overall",
    //     );

    //     // This might cause issues with the quotient calculation
    // });

    await t.test("very large stat values", () => {
        const startDate = new Date("2024-01-01T00:00:00Z");
        const endDate = new Date("2024-01-31T00:00:00Z");
        const trackingEnd = new Date("2024-02-01T00:00:00Z");

        const start = new PlayerDataPITBuilder(uuid, startDate)
            .forGamemode("overall", (b) => b.kills(1000000))
            .build();

        const end = new PlayerDataPITBuilder(uuid, endDate)
            .forGamemode("overall", (b) => b.kills(2000000))
            .build();

        const current = new PlayerDataPITBuilder(uuid, trackingEnd)
            .forGamemode("overall", (b) => b.kills(2100000))
            .build();

        const result = computeStatProgression(
            [start, end],
            trackingEnd,
            current,
            "kills",
            "overall",
        );

        if (result.error) {
            assert.fail(`Expected success, got error: ${result.reason}`);
        }

        const progression = result;
        assert.strictEqual(progression.stat, "kills");
        assert.ok(progression.nextMilestoneValue > progression.currentValue);
    });
});
